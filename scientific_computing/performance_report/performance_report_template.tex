\documentclass[11pt]{article}

\usepackage[a4paper,includeheadfoot,top=1cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{here}
\usepackage{sectsty}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{gnuplottex}

\title{Proposal title}
\author{
        PI \\
        affiliation,
            \and
        CoPI\\
        affiliation
}
\date{}

%\sectionfont{\large\centering}
%\subsectionfont{\large\centering}
%\subsubsectionfont{\large\centering}
%\paragraphfont{\large\centering}

\begin{document}
\maketitle

\begin{abstract}
 This is the abstract of the proposal \ldots
\end{abstract}

\section{Background and Significance}
The project proposal should be no longer than \emph{10 A4 pages} including graphs and references, and must contain the following information:
\begin{itemize}
 \item Abstract
 \item Background and significance
 \item Scientific goals and objectives
 \item Description of the research methods, algorithms, and code
 \item Parallelization approach, memory requirements
 \item Representative benchmarks and scaling
 \item Performance analysis (link: see how to do it)
 \item Resource justification (annual node hours and disk space)
 \item Project plans: tasks and milestones
 \item Visualization, pre- and post-processing needs
 \item Previous results are mandatory! Please list allocations requested, granted and used in your previous project (if applicable)
 \item Research publications that resulted from these allocations
 \item Development and debugging requirements (not mandatory)
\end{itemize}
Therefore you should follow the structure used in this template, which reflects the official requirements. 
Please check the page with the general instructions for \href{http://www.cscs.ch/user_lab/allocation_schemes/submission100/index.html}{Proposal Submission} on the \href{www.cscs.ch}{CSCS Website} for more details. 

\section{Scientific Goals and Objectives}
\ldots 

\section{Research Method, Algorithms and Code}
Please insert in this section a comprehensive explanation with a brief list of libraries used: fftw, parallel-hdf5, petsc, \ldots

\section{Parallelisation Approach and Memory Requirements}
Please report in this section the parallel approach employed to address the proposed computational study with the selected code.
For instance report if using MPI distributed parallelism or hybrid MPI/OpenMP, including details like the type of MPI communication, 
halo cell exchange and which part of the code is taking advantage of shared memory parallelism. 
You should also point out which portions of the selected code used GPU or OpenACC/CUDA \ldots

\section{Representative Benchmarks and Scaling}
Please report in this section the mandatory strong scaling tests performed using the selected code to address the proposed study 
with a representative system to be investigated during the research work. 
The scope of this test is to choose the most efficient job size to run the performance analysis on your representative system 
that will be reported in the next section. 
You should therefore select meaningful job sizes for your representative system, compatible with reasonably short runtimes: 
the lowest number of nodes might be determined by memory and wall-time constraints, while the highest number of nodes tested 
should allow you identify the job size at which you reach $\sim 50\%$ of the parallel efficiency, given by the ideal scaling. 
Weak scaling tests might be provided as well, in addition to the srong scaling scalability data. 

Figure~\ref{fig:scaling} shows the scalability plot for our example system: we start the scalability study with a job size of 8 nodes, 
whose runtime will be used as reference to compute the speed-up of larger job sizes. 
We then proceed doubling the number of nodes and checking the corresponding speed-up, until we are sure to have reached the $50\%$ 
limit in parallel efficiency. 

\begin{figure}[H]
 \begin{center}
  \begin{gnuplot}
   % gnuplot script file to create a scalability plot
   set terminal latex
   set xlabel "Number of Nodes"
   set ylabel "Speed-up"
   # plot legend
   set key left
   set size 1.,1.
   plot "-" w linespoints title "Representative system", x/8 w lines lt 3 title "Ideal Speed-up"
   8 1.0
   16 1.9
   32 3.7
   64 6.0
   128 7.5
   e
   8 1.0
   16 1.75
   32 3.0
   64 5.0
   128 7.0
  \end{gnuplot}
 \end{center}
 \caption{Scalability test: strong scaling efficiency vs. ideal speed-up for the representative system}
 \label{fig:scaling}
\end{figure}

\section{Performance Analysis}
We report in the present section a summary of the performance analysis conducted on the representative system 
at the job size selected in the previous section, which reached $\sim 50\%$ parallel efficiency.
We have followed the instructions available on the section 
\href{http://usertest.cscs.ch/scientific_computing/performance_report}{Performance Report} 
of the \href{CSCS User Portal}{user.cscs.ch}, in order to instrument the executable of the selected code 
with \emph{Cray Performance and Analysis Tools}. 
The results of the run with the instrumented executable are the report file with extension \verb!.rpt! which we attach at the time of the 
proposal submission and the larger apprentice file with extension \verb!.ap2!: 
we will save both files on our \verb!$HOME! or \verb!$PROJECT! folder and make them readable to allow CSCS technical reviewers inspect them.  
We have documented a single production system: in case your project is split into multiple production runs with the same resources requirements, 
then please choose the most representative of them. Please find below the required summary data extracted from the report file:

\begin{verbatim}
Experiment:                   lite  lite/gpu     
Number of PEs (MPI ranks):      16
Numbers of PEs per Node:         1  PE on each of  16  Nodes
Numbers of Threads per PE:   1,114
Number of Cores per Socket:     12
Execution start time:  Tue Mar 28 15:15:55 2017
System name and speed:  nid02294  2601 MHz (approx)
Intel haswell CPU  Family:  6  Model: 63  Stepping:  2


Avg Process Time:     2,100 secs             
High Memory:       13,977.3 MBytes     873.6 MBytes per PE
I/O Read Rate:    67.110363 MBytes/sec       

|  31.8% |   664.415775 |         -- |    -- |     35,648.0 |MPI_SYNC
|   2.8% |    58.511390 |         -- |    -- | 14,458,788.1 |MPI

|  59.2% | 1,236.266484 | 110.728787 |  8.8% |          1.0 |USER
\end{verbatim}

\section{Resources Justification}
The computation of the required time should start with the node hours required for a single timestep.
As an example, the values in Table~\ref{table:derivation_node_hours} sum up to 107500 node hours.
\begin{table}[H]
 \begin{center}
  \begin{tabular}{|c|c|c|}
   \hline
   & simulation type 1 & simulation type 2 \\ 
   \hline
   number of simulations & 2 & 3 \\
   \hline
   node hours per timestep & 1 & 1.5 \\
   \hline
   number of timesteps per simulation & 20000 & 15000 \\
   \hline
   node hours & 40000 & 67500 \\
   \hline
  \end{tabular}
 \end{center}
 \caption{Derivation of node hours}
 \label{table:derivation_node_hours}
\end{table}

\section{Project Plans: Tasks and Milestones}
\ldots

\section{Visualization, pre- and post-processing}
\ldots

\section{Results from Previous Allocations}
\ldots

\section{Research publications from Previous Allocations}
\ldots

\section{Development and debugging requirements}
\ldots 

\section*{References}
\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
